1) Annotation -----
몇가지 한정되지만, 커스텀 어노테이션을 만들 수도 있다. 
어노테이션의 본질적인 목적은 소스코드에 메타데이터를 표현하는 것이다. 
단순히 부가적인 표현뿐만 아니라 리플렉션을 이용하면 어노테이션 지정만으로도 원하는 클래스를 주입하는 것이 가능하다.

여기서 메타데이터란 데이터에 관한 데이터를 의미한다. 
어느 목적을 가지고 만들어지는 데이터를 의미하는데, 
다른 데이터를 설명해주는 데이터라고 생각하면 된다. 
대량의 정보들 속에서도 정보를 효율적으로 찾기 위해 일정한 규칙과 콘텐츠에 대해 부여되는 데이터이다.

일반적으로 Meta는 ~에 관한(about)이라는 의미로 사용된다. 

2) Built-in Annotation -----
- @Override : 메소드가 오버라이드 되었는지 검증한다.
- @Deprecated : 메소드를 사용하지 말도록 유도한다. 만약 사용한다면 컴파일 경고를 일으킨다.
- @SuppressWarnings : 컴파일 경고를 무시하도록 하낟.
- @SafeVarargs : 제네릭 같은 가변인자 매개변수를 사용할 때 경고를 무시한다.(Java7 이상)
- FunctionalInterface : 람다 함수등을 위한 인터페이스를 지정한다. 메소드가 없거나 두 개 이상되면 컴파일 오류가 난다.(Java8 이상)

3) Meta Annotations -----
메타 어노테이션도 존재한다. 이 메타 어노테이션을 통해서 커스텀 어노테이션의 생성이 가능하다.

- @Retention : 어노테이션의 범위라고 할 수 있다. 어떤 시점까지 어노테이션이 영향을 미치는지 결정
- @Documented : 문서에도 어노테이션의 정보가 표현된다.
- @Target : 어노테이션이 적용할 위치를 결정
- @Inherited : 이 어노테이션을 선언하면 부모클래스에서 어노테이션을 상속 받을 수 있다.
- @Repeatable : 반복적으로 어노테이션을 선언할 수 있게 한다.

4) Declare Custom Annotation -----


** 기존 웹 애플리케이션이 가지고 있던 문제점 **
기존의 자바 웹 애플리케이션들은 선언적인 프로그래밍 방식이 강했다. 선언적이기 떄문에 
프로그램의 전체 및 각 레이어 별로 구성과 설정 값들을 외부의 XML설정파일에 명시하는 방식이었다.

변경이 될 수 있는 데이터들을 최대한 코드가 아닌 외부 설정 파일에 분리하기 때문에 재 컴파일 과정을 
거치지 않더라도 쉽게 변경된 사항을 바꿀 수 있었고 그에 따라 유연도가 증가했다. 

그러나

프로그램의 작서을 위해서 매번 많은 수의 설정파일을 작성해야 하는 단점이 존재했고, 
이에 따라 규모가 커질수록 설정의 양도 많아지게 되면서 이를 잘 구조화할 수 있는 방법도 필요하게 되었다.

도메인의 데이터 처리정보가 Model Class, Service Class, XML 설정 파일에 분산되어 있어서 
이를 확인하기 위해서는 전체를 모두 확인해야 했다.
***********************************

위의 문제에서 어노테이션을 이용하였을 경우에 데이터에 대한 유효성 검사조건을 어노테이션을 사용하여
Model 클래스에 직접 명시함으로써 해당 데이터들에 대한 유효조건을 쉽게 파악할 수 있게 되며,
코드가 깔끔해지고 어노테이션의 재사용이 가능해졌다. 결과적으로 설정파일이 간결해지고, 
View 페이지와 객체 또는 메소드의 맵핑을 명확하게 할 수 있다.

하지만 그렇다고 XML을 사용하지 않을 것인가? 그것 또한 아니다. XML은 유연성을 확보해준다.
어노테이션을 사용하여 한번 빌드딘 코드는 수정을 위해서 재컴파일을 해야한다는 단점이 존재하지만,
애플리케이션 전체적인 설정이나 디플로이 환경에 따라 변경되는 사항들은 XML설정을 사용한다.

실질적으로 각각의 장단점을 파악하고, 언제 무엇을 사용해야 할지 아는 것이 매우 중요하다.

-- 일반적인 어노테이션의 용도
(1) 문서화
(2) 컴파일러 체크
(3) 코드 분석